import getBoundaries from '../utils/getBoundaries';

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
export default function computeAutoPlacement(
  placement,
  refRect,
  popper,
  reference,
  boundariesElement,
  padding = 0
) {
  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  const boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  const rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top,
      getArea: function() { return this.width * this.height; },
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height,
      getArea: function() { return this.width * this.height; },
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom,
      getArea: function() { return this.width * this.height; },
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height,
      getArea: function() { return this.width * this.height; },
    },
  };
  
  const sortedRects = [];
  for (const rect in rects) {
    sortedRects.push([rect, rects[rect]]);
  }

  sortedRects.sort(function(a, b) {
    return b[1].getArea() - a[1].getArea();
  });

  const resultRects = sortedRects.filter(function(rect) {
    if (rect[1].width >= popper.clientWidth && rect[1].height >= popper.clientHeight) {
      return rect;
    }
  });


  let computedPlacement = '';
  if (resultRects.length > 0) {
    computedPlacement = resultRects[0][0];
  } else {
    computedPlacement = sortedRects[0][0];
  }

  const variation = placement.split('-')[1];

  return computedPlacement + (variation ? `-${variation}` : '');
}
