import getPopperClientRect from '../utils/getPopperClientRect';
import getOppositePlacement from '../utils/getOppositePlacement';
import getScrollParent from '../utils/getScrollParent';
import getBoundaries from '../utils/getBoundaries';

/**
 * Modifier used to prevent the popper from being positioned outside the boundary.
 *
 * An scenario exists where the reference itself is not within the boundaries. We can
 * say it has "escaped the boundaries" â€” or just "escaped". In this case we need to
 * decide whether the popper should either:
 *
 * - detach from the reference and remain "trapped" in the boundaries, or
 * - if it should be ignore the boundary and "escape with the reference"
 *
 * When `escapeWithReference` is `true`, and reference is completely outside the
 * boundaries, the popper will overflow (or completely leave) the boundaries in order
 * to remain attached to the edge of the reference.
 *
 * @method
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
export default function preventOverflow(data, options) {
    /**
     * Determine if the popper should overflow a boundary edge to stay together with the reference.
     */
    function shouldOverflowBoundary(overflowDirection) {
        if (!options.escapeWithReference) {
            return false;
        }

        if (data.flipped && isSameAxis(data.originalPlacement, overflowDirection)) {
            return true;
        }

        if (!isSameAxis(data.originalPlacement, overflowDirection)) {
            return true;
        }

        return false;
    }
    const order = options.priority;
    const popper = getPopperClientRect(data.offsets.popper);

    const check = {
        left() {
            let left = popper.left;
            if (popper.left < options.boundaries.left && !shouldOverflowBoundary('left')) {
                left = Math.max(popper.left, options.boundaries.left);
            }
            return { left: left };
        },
        right() {
            let left = popper.left;
            if (popper.right > options.boundaries.right && !shouldOverflowBoundary('right')) {
                left = Math.min(popper.left, options.boundaries.right - popper.width);
            }
            return { left: left };
        },
        top() {
            let top = popper.top;
            if (popper.top < options.boundaries.top && !shouldOverflowBoundary('top')) {
                top = Math.max(popper.top, options.boundaries.top);
            }
            return { top: top };
        },
        bottom() {
            let top = popper.top;
            if (popper.bottom > options.boundaries.bottom && !shouldOverflowBoundary('bottom')) {
                top = Math.min(popper.top, options.boundaries.bottom - popper.height);
            }
            return { top: top };
        }
    };

    order.forEach((direction) => {
        data.offsets.popper = Object.assign(popper, check[direction]());
    });

    return data;
}

export function preventOverflowOnLoad(reference, popper, options, modifierOptions) {
    const padding = modifierOptions.padding;
    let scrollParent = getScrollParent(popper);

    // To get informations about the scroll position on Firefox we need documentElement.
    // But obviously, Firefox doesn't give us the real document height if we read documentElement
    // it returns the window height. To fix this, always make sure to use body instead.
    scrollParent === window.document.documentElement && (scrollParent = window.document.body);
    const scrollParentRect = getBoundaries(popper, padding, scrollParent);

    modifierOptions.boundaries = scrollParentRect;
}

/**
 * Determine if two placement values are on the same axis.
 */
function isSameAxis(a, b) {
    // placement syntax:
    //
    //     ( "top" | "right" | "bottom" | "left" ) ( "-start" | "" | "-end" )
    //     |------------- Direction -------------|
    //
    const aDirection = a.split('-')[0];
    const bDirection = b.split('-')[0];

    return aDirection === bDirection || aDirection === getOppositePlacement(b);
}
