# Getting Started

Floating UI is a low-level library for creating "floating"
elements like tooltips, popovers, dropdowns, menus, and more.

The library provides two key functionalities:

1. **Anchored positioning primitives**: Given a reference element
   (such as a button), anchor the floating element next to it
   while simultaneously ensuring it is positioned optimally in
   view by preventing overflow and clipping. The reference
   element may be positioned anywhere on the screen and the
   floating element will remain anchored to it without
   overflowing the viewport edges using various adjustment
   techniques called
   [middleware](https://floating-ui.com/docs/middleware).
2. **Interaction primitives**: Add accessible interactions that
   power floating elements to follow WAI-ARIA authoring
   practices, including event listeners, click outside/escape key
   dismissing, ARIA attributes, focus trapping, list navigation,
   typeahead, etc. This functionality is currently available for
   React DOM but will be made agnostic in the future.

The positioning engine features a tiny 600-byte core with strong
tree-shaking support, is extensible through custom middleware,
and can support any platform.

## Install

Choose the package that suits you.

### Vanilla DOM positioning engine

Use with vanilla JavaScript or a non-React framework
([view tutorial](/docs/tutorial)).

```shell
npm install @floating-ui/dom
```

### React DOM positioning engine

Use with React DOM ([view docs](/docs/react-dom)).

```shell
npm install @floating-ui/react-dom
```

### React DOM interactions and positioning engine

Primitive hooks and components, in addition to the positioning
engine, to use with React DOM
([view docs](/docs/react-dom-interactions)).

```shell
npm install @floating-ui/react-dom-interactions
```

### React Native positioning engine

Use with React Native ([view docs](/docs/react-native)).

```shell
npm install @floating-ui/react-native
```

### Canvas or other platforms

Learn about creating a [Platform](/docs/platform).

```shell
npm install @floating-ui/core
```

## CDN

<details>
  <summary>View details</summary>

Floating UI can be loaded via CDN using ESM or UMD format.

#### ESM

#### Import maps

When working in a low or no build context, it can be useful to
consume code with bare module specifiers, e.g.
`import * from '@floating-ui/dom';{:js}`. In order to do so,
[import maps](https://github.com/WICG/import-maps) clarify the
origin of such references for the browser.

  <details>
  <summary>JSPM import map example</summary>

```mdx
<script type="importmap">
  {
    "imports": {
      "@floating-ui/dom": "https://ga.jspm.io/npm:@floating-ui/dom@__DOM_VERSION__/dist/floating-ui.dom.esm.js"
    },
    "scopes": {
      "https://ga.jspm.io/": {
        "@floating-ui/core": "https://ga.jspm.io/npm:@floating-ui/core@__CORE_VERSION__/dist/floating-ui.core.esm.js"
      }
    }
  }
</script>
```

JSPM provides a [generator](https://generator.jspm.io/) for
leveraging this API with their CDN.

</details>

#### UMD

```html
<script src="https://unpkg.com/@floating-ui/core@__CORE_VERSION__"></script>
<script src="https://unpkg.com/@floating-ui/dom@__DOM_VERSION__"></script>
```

All exports will be available on `window.FloatingUIDOM{:js}`.

</details>

## Package entry points

Floating UI outlines [package entry points](https://nodejs.org/api/packages.html#package-entry-points)
via the `exports{:.objectKey}` field and lists entries for the
the `require{:.objectKey}`, `import{:.objectKey}`, and `browser{:.objectKey}`
[export conditions](https://nodejs.org/api/packages.html#packages_conditional_exports).
When leveraging a the library with a full build process, ensure
that you build tool is aware of, or and can manage, JS leveraging the
`process.env{:js}` object.

Floating UI leverages the value of properties of
this object like `NODE_ENV{:.objectKey}` to customize the features that are available
within the library. In particular, when `process.env.NODE_ENV !== "production"{:js}`
debug logging will be `console.warn{:js}`ed into the browser.

If you're using a bundler like webpack, Vite, or Parcel, this is
handled for you **automatically**. While each offers their own advanced
customization like here in [Vite](https://vitejs.dev/config/#resolve-conditions)
to ensure you have the ability to make the best decisions for you application.

If this is not handled, as in _no- or low-build environments_,
you should leverage the `browser{:.objectKey}` export condition
which does not feature usage of the `process.env{:js}` object.
This export condition is further broken into `default{:.objectKey}` and
`development{:.objectKey}` conditions:

- `"development"{:js}`: unminified with debug logging
- `"default"{:js}`: minified with no debug logging

These are accessed differently for each tool.

<details>
  <summary>Rollup example</summary>

Using the `@rollup/node-resolve{:.string}` plugin, you can select
the "development" build from the "browser" exports with the
`exportConditions{:.objectKey}` option:

```js
import {nodeResolve} from '@rollup/plugin-node-resolve';

export default {
  // ...
  plugins: [
    nodeResolve({
      exportConditions: ['browser', 'development'],
    }),
  ],
};
```

or, by combining the [`browser{:.objectKey}`](https://github.com/rollup/plugins/tree/master/packages/node-resolve#browser)
option with the `exportConditions{:.objectKey}` option:

import {nodeResolve} from '@rollup/plugin-node-resolve';

export default {
  // ...
  plugins: [
    nodeResolve({
      exportConditions: ['development'],
      browser: true,
    }),
  ],
};
```

Leaving "development" out of these configurations
will point to the "production" build. 

</details>
